grammar org.psikeds.kb.modelling.PsiKedsXtxKrl with org.eclipse.xtext.common.Terminals

generate psiKedsXtxKrl "http://www.psikeds.org/kb/modelling/PsiKedsXtxKrl"

/* (A) a valid psiKeds knowledge base needs ... */
KnowledgeBase:
  /* (1) first, a valid psiKeds knowledge base must/can offer some meta information */
 
  'name' knowledgeBaseName=STRING
  'release' releaseNumber=STRING
  '(C)' copyRightLine=STRING
  'created' firstCreationDate=YYYYMMDD
  'modified' lastModificationDate=YYYYMMDD
  'engineer' (creatorName+=STRING)*
  'description' (description+=STRING)*

  
  /* (2) second, a valid psiKeds knowledge base can define sensors and lists
   * their specific value range. Sensors are methods to perceive / describe 
   * / denote features of real domain objects. They link the attribute-values 
   * (as they are noted in the knowledge entities) to the real world features. 
   * 
   * Sensors a type consistent: they can be lists of string values, integer 
   * values, float values, integer ranges, or float ranges.
   * 
   * [Note: 
   * - if you want to define a knowledge base being only composed of purposes, 
   *   variants, variant contexts, and logical rules, you do not need any 
   *   sensors. So, the list of sensors can be empty.
   * - what ever you want to use for describing / specifying the domain
   *   objects must be defined as sensor value in this area. Later on all
   *   knowledge base entities can only refer to these primary definitions.
   * ]
   */
  (sensorAreas+=(
    SensorStringValueArea|
    SensorIntDigitArea|
    SensorFloatDigitArea|
    SensorIntRangeArea | /* only definable, currently psiKeds won't evaluate these elements */
    SensorFloatRangeArea /* only definable, currently psiKeds won't evaluate these elements */
  ))*

	/* (2.B) some concepts to denote / describe / cluster objects */
	(listOfConcepts+=Concept)+
  
    
	/* (3) a list of at least one purpose */
	(listOfPurposes+=Purpose)+
	
  	/* (4) a list of at least one variant */	
	(listOfVariants+=Variant)+
	
	/* (5) a list of at least one 
	 * [this purpose] is-fulfilled-by [these variants] 
	 * statements
	 */
	(listOfIsFulfilledByStatements+=IsFulfilledBy)+
	
  	/* (6) a possibly empty list of 
   	* [this variant] is-constituted-by [something fulfilling these purposes] statements
   	*/	
	(listOfIsConstitutedByStatements+=IsConstitutedBy)*
	
	/* (7) a possibly empty list of events used by logical rules*/ 
    (listOfEvents+=(ContextualLogicEvent|ContextEventClosedBySensor))*
 
  	/* (8.A) a possibly empty list of logical rules */ 
  	(listOfLogicalRules+=(LogicalEnforcer|LogicalRule|RelationalConstraint))* 
;


/* (B) definitions, which are multiply used by other elements
 * either by being embedded into other xtext defintions
 * or by being used as references
 */

/* (B.0) my terminals */
terminal YYYYMMDD:
  ('0'..'9')('0'..'9')('0'..'9')('0'..'9')'-'?
  (('0'('1'..'9'))|('1'('0'..'2')))'-'?
  ( ('0'('1'..'9')) |
    (('1'|'2')('0'..'9'))|
    ('3'('0'..'1'))
  )
 ;

/* (B.1) an expandable label */
XLabel:
  'label' label=STRING
  ('description' description=STRING)?
;

/* (B.1) a pure label */
PLabel:
  'label' label=STRING
;

/* (B.1) a complete describing label */
DLabel:
  'label' label=STRING
  'description' description=STRING
;

/* (B.2) Sensor declaration for grouping sensor values by referencing to 
 * the grouping class: sensors are instruments for 'looking' into the domain 
 * (real world) and to deliver features of the perceived object. 
 * A sensor can/should only deliver values of the same type.
 */

Sensor:
  'sensor' name=ID '{'
  labeledDescription=XLabel
  ('unit' unit=STRING)?
  '}'
;

SensorReference:
  '[sensor]>' sensorRef=[Sensor]
;

/* (B.2.1) a sensor with an explicitly defined set of perceivable string values 
 * Note: 
 * - It is up to the knowledge engineer to insert a reference to the right 
 *   (the intended) sensor into the definition of the allowed values
 */
SensorStringValueArea:
  sensor=Sensor
  (sensorStringValues+=SensorStringValue)+
;

SensorStringValue:
  'strAtt' name=ID '[' class=[Sensor] '->' value=STRING ']'
;

/* (B.2.2) a sensor with an explicitly defined set of perceivable integer values 
 * Note: 
 * - It is up to the knowledge engineer to insert a reference to the right 
 *   (the intended) sensor into the definition of the allowed values
 */
SensorIntDigitArea:
  sensor=Sensor
  (sensorIntDigits+=SensorIntDigit)+
;

SensorIntDigit:
  'intAtt' name=ID '[' class=[Sensor] '->' value=INT ']'
;

/* (B.2.3) a sensor with an explicitly defined set of perceivable float values 
 * Note: 
 * - It is up to the knowledge engineer to insert a reference to the right 
 *   (the intended) sensor into the definition of the allowed values
 */

SensorFloatDigitArea:
  sensor=Sensor
  (sensorFloatDigits+=SensorFloatDigit)+
;

SensorFloatDigit:
  'floatAtt' name=ID '[' class=[Sensor] '->' value=FloatValue ']'
;

FloatValue:
  (INT)?'.'INT
;

/* (B.2.4) a sensor with an implicitly defined set of perceivable integer values
 * Note: 
 * - It is up to the knowledge engineer to insert a reference to the right 
 *   (the intended) sensor into the definition of the allowed ranges
 * - References to ranges can be assigned to variants for being decreased
 *   by functions and relations. But they can not be used in logical rules
 * - Ranges will only be usable in later versions of psiKeds (> 1.0.0)
 */

SensorIntRangeArea:
  sensor=Sensor
  (sensorIntRanges+=SensorIntRange)+
;

SensorIntRange:
  'intRangeAtt' name=ID '[' class=[Sensor] '->' value=IntRange ']'
;

IntRange:
  '(' 'min' minVal=INT ',' 'max' maxVal=INT ',' 'inc' incVal=INT ')'
;

/* (B.2.5) a sensor with an implicitly defined set of perceivable float values
 * Note: 
 * - It is up to the knowledge engineer to insert a reference to the right 
 *   (the intended) sensor into the definition of the allowed ranges
 * - References to ranges can be assigned to variants for being decreased
 *   by functions and relations. But they can not be used in logical rules
 * - Ranges will only be usable in later versions of psiKeds (> 1.0.0)
 */

SensorFloatRangeArea:
  sensor=Sensor
  (sensorFloatRanges+=SensorFloatRange)+
;

SensorFloatRange:
  'floatRangeAtt' name=ID '[' class=[Sensor] '>>' value=FloatRange ']'
;

FloatRange:
  '(' 'min' minVal=FloatValue ',' 'max' maxVal=FloatValue ',' 'inc' incVal=FloatValue ')'
;

/* (C) the top down definitions */

/* (C.1) elements to define concepts: Concepts are sets of different
 * attributes. An attribute is a feature value perceived by a sensor.
 * Concepts shall contain only attributes of different sensors.
 * 
 * Note:
 * - It is up to the knowledge engineer not to insert more than one value of
 *   the same sensor into one concept
 */


Concept:
  'concept' name=ID '{'
    labeledDescription=XLabel
    '['
      headAtt=(AttStrReference|AttIntReference|AttFloatReference)
      ( 'and'
      tailAtts+=(AttStrReference|AttIntReference|AttFloatReference))*   
    ']'
'}';
/* (C.1.1) Attribute based on a string value */
AttStrReference:
  '[str]>' attStrRef=[SensorStringValue]
;
/* (C.1.2) Attribute based on an integer value */
AttIntReference:
  '[int]>' attIntRef=[SensorIntDigit]
;
/* (C.1.3) Attribute based on an float value */
AttFloatReference:
  '[float]>' attFloatRef=[SensorFloatDigit]
;

ConceptReference:
  '[concept]>' conceptRef=[Concept]
;

/* (C.2) definitions of purposes  */ 
Purpose:
	'purpose' name=ID '{'
	 	('root' root=('true'|'false'))?
	 	labeledDescription=XLabel
	'}'
;

/* (C.3) definitions of variants  */

Variant:
	'variant' name=ID '{'
    labeledDescription=XLabel
   /* 0 - n lists of one of these context-free features */
   (oneOfTheseAttributeList+=(OneOfTheseAttributeList)*)
   /* one list of one of these terminal concepts */
   (oneOfTheseConceptList=OneOfTheseConceptList)?
   /* list of empirically evoked secondary concept */
	'}'
;	

VariantReference:
  '[variant]>' variantRef=[Variant]
;
OneOfTheseAttributeList:
  'sensed by' sensor=[Sensor]
  'as ['
     oneOfThis=
        (ConsistentStrAttrList
      | ConsistentIntAttrList
      | ConsistentFloatAttrList)
  ']'
;

ConsistentStrAttrList:
  headStrAtt=AttStrReference
  ('or' tailStrAtts+=AttStrReference)*
;

ConsistentIntAttrList:
  headIntAtt=AttIntReference
  ('or' tailIntAtts+=AttIntReference)+
;

ConsistentFloatAttrList:
  headFloatAtt=AttFloatReference
  ('or' tailFloatAtts+=AttFloatReference)+
;


OneOfTheseConceptList:
  {OneOfTheseConceptList}
  'classified as ['
     headConceptReference=ConceptReference
     ('or' tailConceptReferences+=(ConceptReference))*
  ']'
;


/* (C.4) is fulfilled by statement  */

IsFulfilledBy:
  'purpose.system' purposeRef=[Purpose] 'isFulfilledBy' '{' 
    (variantRefs+=[Variant])+ '}'
;

/* (C.5) is constituted by statement   */
 
IsConstitutedBy:
  'purpose.variant' variantRef=[Variant] 'isConstitutedBy' '{'
    (purposeRefs+=[Purpose])* '}'
;

/* (C.6) elements for defining events being perceptible during the inference process*/

ContextualLogicEvent:
	ContextEventClosedByVariant
    | ContextEventClosedByString
    | ContextEventClosedByInt
    | ContextEventClosedByFloat
    | ContextEventClosedByConcept
;

/* Note:
 * - it is up to the knowledge engineer to select the same variant
 *   as context and as fact!
 */
ContextEventClosedByVariant:
  'event.var' name=ID '['
    labeledDescription=XLabel
    'context' context=OpenContextualPath
     (negation?='NOT')?
    'fact' fact=VariantReference
  ']'
;


ContextEventClosedByString:
  'event.str' name=ID '['
    labeledDescription=XLabel
    'context' context=ClosedContextualPath
    (negation?='NOT')?
    'fact' fact=AttStrReference
  ']'
;

ContextEventClosedByInt:
  'event.int' name=ID '['
    labeledDescription=XLabel
    'context' context=ClosedContextualPath
    (negation?='NOT')?
    'fact' fact=AttIntReference
  ']'
;

ContextEventClosedByFloat:
  'event.float' name=ID '['
    labeledDescription=XLabel
    'context' context=ClosedContextualPath
    (negation?='NOT')?
    'fact' fact=AttFloatReference
  ']'
;

ContextEventClosedByConcept:
  'event.concept' name=ID '['
    labeledDescription=XLabel
    'context' context=ClosedContextualPath
    (negation?='NOT')?
    'fact' fact=ConceptReference
  ']'
;

ContextEventClosedBySensor:
  'event.sensor' name=ID '['
    labeledDescription=XLabel
    'context' context=ClosedContextualPath
    'fact' fact=SensorReference
  ']'
;
 
ClosedContextualPath:
  '<'
  (variantPurposeRow += VariantPurposePair)*
  closingVariant = [Variant]
  '>'
;

OpenContextualPath:
  '<'
  (variantPurposeRow += VariantPurposePair)+
  '>'
;



VariantPurposePair:
    variant=[Variant]
    purpose=[Purpose]
;

LogicalEnforcer:
	'logic.enforcer'
	fact=VariantReference
	'->'
	conclusio=[ContextualLogicEvent]
;

LogicalRule:
  'logic.rule'
    headPremise=[ContextualLogicEvent]
   ('and' tailPremise+=([ContextualLogicEvent]))*
  '->'
    conclusio=[ContextualLogicEvent]
;


RelationalConstraint:
   RCEqual | RCUnequal | RCLower | RCLowerOrEqual 
;

/* a == b :: ( reverse is b == a) */
RCEqual:
  'relation.equal'
  firstArg=[ContextEventClosedBySensor]
  '=='
  secondArg=[ContextEventClosedBySensor]
;

/* a != b :: ( reverse is b != a) */
RCUnequal:
  'relation.unequal'
  firstArg=[ContextEventClosedBySensor]
  '!='
  secondArg=[ContextEventClosedBySensor]
;
/* a < b :: ( reverse is b >= a) */
RCLower:
  'relation.less'
  aArg=[ContextEventClosedBySensor]
  '<'
  bArg=[ContextEventClosedBySensor]
;

/* a <= b :: ( reverse is b > a) */
RCLowerOrEqual:
  'relation.less-or-equal'
  aArg=[ContextEventClosedBySensor]
  '<='
  bArg=[ContextEventClosedBySensor]
;


