/*
 * generated by Xtext
 */
package org.psikeds.kb.modelling.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess	

import org.eclipse.emf.common.util.EList
import org.psikeds.kb.modelling.psiKedsXtxKrl.KnowledgeBase
import org.psikeds.kb.modelling.psiKedsXtxKrl.XLabel

import org.psikeds.kb.modelling.psiKedsXtxKrl.Sensor
import org.psikeds.kb.modelling.psiKedsXtxKrl.SensorStringValueArea
import org.psikeds.kb.modelling.psiKedsXtxKrl.SensorIntDigitArea
import org.psikeds.kb.modelling.psiKedsXtxKrl.SensorFloatDigitArea
import org.psikeds.kb.modelling.psiKedsXtxKrl.SensorIntRangeArea
import org.psikeds.kb.modelling.psiKedsXtxKrl.SensorFloatRangeArea
import org.psikeds.kb.modelling.psiKedsXtxKrl.Concept
import org.psikeds.kb.modelling.psiKedsXtxKrl.Variant
import org.psikeds.kb.modelling.psiKedsXtxKrl.IsFulfilledBy
import org.psikeds.kb.modelling.psiKedsXtxKrl.IsConstitutedBy
import org.psikeds.kb.modelling.psiKedsXtxKrl.OpenContextualPath
import org.psikeds.kb.modelling.psiKedsXtxKrl.ClosedContextualPath

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class PsiKedsXtxKrlGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val model = resource.contents.head as KnowledgeBase
		fsa.generateFile(model.kbId+'-knowledbase.xml', model.toCode)
	}
	

	def CharSequence toCode(KnowledgeBase base) '''
<?xml version="1.0" encoding="UTF-8"?>
<!--
«base.kbId» : «base?.kbRelease» : «base?.kbTeaser» 
(C) «IF base.kbCopyRight != null»«base.kbCopyRight»«ENDIF» 

A psiKeds knowledge base: developed for being used by the inference machine
of psiKeds, the purpose system induced knowledge entity delivery system
http://www.psikeds.org/) and generated by the psiKedsXtXKrl-Generator

«IF base.kbLicense != null»
This file is licensed under the conditions of a/the
«base.kbLicense»«ENDIF»

-->
<kb:knowledgebase xmlns="http://org.psikeds.knowledgebase"
  xmlns:kb="http://org.psikeds.knowledgebase"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://org.psikeds.knowledgebase kb.xsd">
  <kb:meta>
    «IF base.kbFirstCreationDate != null»
    <kb:created>«base.kbFirstCreationDate»</kb:created>«ENDIF»
    «IF base.kbLastModificationDate != null»
    <kb:lastmodified>«base.kbLastModificationDate»</kb:lastmodified>«ENDIF»
    «IF base.kbLanguage != null»
    <kb:language>«base.kbLanguage»</kb:language>«ENDIF»
    «IF base.kbRelease != null»
    <kb:version>«base.kbRelease»</kb:version>«ENDIF»
    «IF base.kbCreatorName.length > 0»
      «base.kbCreatorName.map[stringToXmlTag(it,'kb:creator')].join()»
	  «ENDIF»
    «IF base.kbDescription.length > 0»
      «base.kbDescription.map[stringToXmlTag(it,'kb:description')].join()»
    «ENDIF»
  </kb:meta>
  <kb:data>
    <kb:sensors> 
    «IF (base.sensorStringValueAreas.length > 0) »
      «FOR sensorStringArea : base.sensorStringValueAreas»
        «sensorStringArea.toXml»
      «ENDFOR»
    «ENDIF»
    «IF (base.sensorIntDigitAreas.length > 0) »
      «FOR sensorIntDigitArea : base.sensorIntDigitAreas»
        «sensorIntDigitArea.toXml»
      «ENDFOR»
    «ENDIF»
    «IF (base.sensorFloatDigitAreas.length > 0) »
      «FOR sensorFloatDigitArea : base.sensorFloatDigitAreas»
        «sensorFloatDigitArea.toXml»
      «ENDFOR»
    «ENDIF» 
    «IF (base.sensorIntRangeArea.length > 0) »
      «FOR sensorIntRangeArea : base.sensorIntRangeArea»
        «sensorIntRangeArea.toXml»
      «ENDFOR»
    «ENDIF» 
    «IF (base.sensorFloatRangeArea.length > 0) »
      «FOR sensorFloatRangeArea : base.sensorFloatRangeArea»
        «sensorFloatRangeArea.toXml»
      «ENDFOR»
    «ENDIF» 
    </kb:sensors>
  
    <kb:concepts>
    «IF (base.listOfConcepts.length > 0) »
      «FOR concept : base.listOfConcepts» «concept.toXml»«ENDFOR»
    «ENDIF» 
    </kb:concepts>
    
    «IF base.listOfPurposes.length > 0»
    <kb:purposes>
      «FOR purpose : base.listOfPurposes»
      <kb:purpose id="«purpose.name»" «IF purpose.root != null»root="«purpose.root»"«ELSE»root="false"«ENDIF»>
        «purpose.labeledDescription.toXml("")»
      </kb:purpose>
      «ENDFOR»
    </kb:purposes>
    «ENDIF»   
    
    «IF base.listOfVariants.length > 0»
    <kb:variants>
      «FOR variant : base.listOfVariants»«variant.toXml»«ENDFOR»
    </kb:variants>  
    «ENDIF»
    
    «IF base.listOfIsFulfilledByStatements.length > 0»
    <kb:alternatives>
      «FOR isFulfilledBy : base.listOfIsFulfilledByStatements»
        «isFulfilledBy.toXml»
      «ENDFOR»
    </kb:alternatives>  
    «ENDIF»
     
    «IF base.listOfIsConstitutedByStatements.length > 0»
    <kb:constituents>
      «FOR isConstitutedBy : base.listOfIsConstitutedByStatements»
        «isConstitutedBy.toXml»
      «ENDFOR»
    </kb:constituents> 
    «ENDIF»
    «IF ( ( base.listOfContextualEnforceEvents != null &&
            base.listOfContextualEnforceEvents.length > 0)
        || ( base.listOfContextEventClosedByVariants != null &&
            base.listOfContextEventClosedByVariants.length > 0 )
        || ( base.listOfContextEventClosedByStrings != null &&
            base.listOfContextEventClosedByStrings.length > 0)
        || ( base.listOfContextEventClosedByInts != null &&
            base.listOfContextEventClosedByInts.length > 0)
        || ( base.listOfContextEventClosedByFloats != null &&
            base.listOfContextEventClosedByFloats.length > 0)
        || ( base.listOfContextEventClosedByConcepts != null &&
            base.listOfContextEventClosedByConcepts.length > 0)         
        )»
    <kb:events>
      «IF ( base.listOfContextualEnforceEvents != null )»
      «FOR enforceEvent :  base.listOfContextualEnforceEvents»
         <kb:event id="«enforceEvent.name»" 
           nexusId="«enforceEvent.fact.ref.name»" 
           context="«enforceEvent.fact.ref.name»">
           «enforceEvent.labeledDescription.toXml("")»
           <kb:variantTrigger triggerID="«enforceEvent.fact.ref.name»" />
         </kb:event>
      «ENDFOR»
      «ENDIF»
      «IF ( base.listOfContextEventClosedByVariants != null )»
      «FOR varEvent :  base.listOfContextEventClosedByVariants»
         <kb:event id="«varEvent.name»" 
           «varEvent.context.toXml»>
           «varEvent.labeledDescription.toXml("")»
           «IF varEvent.negation»<kb:not />«ENDIF»
           <kb:variantTrigger triggerID="«varEvent.fact.ref.name»" />
         </kb:event>
      «ENDFOR»
      «ENDIF» 
      «IF ( base.listOfContextEventClosedByStrings != null )»
      «FOR attStrEvent : base.listOfContextEventClosedByStrings»
         <kb:event id="«attStrEvent.name»" 
           «attStrEvent.context.toXml»>
           «attStrEvent.labeledDescription.toXml("")»
           «IF attStrEvent.negation»<kb:not />«ENDIF»
           <kb:attStrTrigger triggerID="«attStrEvent.fact.ref.name»" />
         </kb:event>
      «ENDFOR»
      «ENDIF»
      «IF ( base.listOfContextEventClosedByInts != null )»
      «FOR attIntEvent : base.listOfContextEventClosedByInts»
         <kb:event id="«attIntEvent.name»" 
           «attIntEvent.context.toXml»>
           «attIntEvent.labeledDescription.toXml("")»
           «IF attIntEvent.negation»<kb:not />«ENDIF»
           <kb:attIntTrigger triggerID="«attIntEvent.fact.ref.name»" />
         </kb:event>
      «ENDFOR»
      «ENDIF»
      «IF ( base.listOfContextEventClosedByFloats != null )»
      «FOR attFloatEvent : base.listOfContextEventClosedByFloats»
         <kb:event id="«attFloatEvent.name»" 
           «attFloatEvent.context.toXml»>
           «attFloatEvent.labeledDescription.toXml("")»
           «IF attFloatEvent.negation»<kb:not />«ENDIF»
           <kb:attFloatTrigger triggerID="«attFloatEvent.fact.ref.name»" />
         </kb:event>
      «ENDFOR»
      «ENDIF»
      «IF ( base.listOfContextEventClosedByConcepts != null )»
      «FOR concEvent : base.listOfContextEventClosedByConcepts»
         <kb:event id="«concEvent.name»" 
           «concEvent.context.toXml»>
           «concEvent.labeledDescription.toXml("")»
           «IF concEvent.negation»<kb:not />«ENDIF»
           <kb:conceptTrigger triggerID="«concEvent.fact.ref.name»" />
         </kb:event>
      «ENDFOR»
      «ENDIF»      
    </kb:events> 
    «ENDIF»
    
    «IF  ( base.listOfRelationsParameters != null &&
            base.listOfRelationsParameters.length > 0)»
    <kb:parameters>
      «FOR parameter :  base.listOfRelationsParameters»
         <kb:parameter id="«parameter.name»" 
           «parameter.context.toXml»>
           «parameter.labeledDescription.toXml("")»
           <kb:valueSet sensorID="«parameter.fact.ref.name»" />
         </kb:parameter>
      «ENDFOR»
    </kb:parameters> 
    «ENDIF»
    
   «IF ( ( base.listOfLogicalEnforcers != null &&
            base.listOfLogicalEnforcers.length > 0)
        || ( base.listOfLogicalRules != null &&
            base.listOfLogicalRules.length > 0)         
        )»
    <kb:rules>
      «IF ( base.listOfLogicalEnforcers != null )»
      «FOR enforcerRule :  base.listOfLogicalEnforcers»
         <kb:rule id="«enforcerRule.name»"
            premiseEventIDs="«enforcerRule.premise.name»" 
            conclusioEventID="«enforcerRule.conclusio.name»" > 
           «enforcerRule.labeledDescription.toXml("")»
         </kb:rule>
      «ENDFOR»
      «ENDIF» 

      «IF ( base.listOfLogicalRules != null )»
      «FOR logicalRule :  base.listOfLogicalRules»
         <kb:rule id="«logicalRule.name»"
           premiseEventIDs="«FOR evPoin : logicalRule.listOfPremiseEvents»«evPoin.name» «ENDFOR»»" 
           conclusioEventID="«logicalRule.conclusio.name»" > 
           «logicalRule.labeledDescription.toXml("")»
         </kb:rule>
      «ENDFOR»
      «ENDIF»    
    </kb:rules> 
    «ENDIF»
    «IF ( base.listOfRelationalConstraints != null &&
            base.listOfRelationalConstraints.length > 0)»
    <kb:relations>
      «FOR relation :  base.listOfRelationalConstraints»
      <kb:relation id="«relation.name»" type="«relation.relationType»"
          lParameter="«relation.firstArg.name»" rParameter="«relation.secondArg.name»"> 
        «relation.labeledDescription.toXml("")»
      </kb:releation>
       «ENDFOR»
    <kb:/relations>    
    «ENDIF»
  </kb:data>    
</kb:knowledgeBase>
	'''
  def String toXml(OpenContextualPath opCtxPath) '''
  nexusId="«opCtxPath.variantPurposeRow.head.variant.name»
  context="«FOR variPurpPair : opCtxPath.variantPurposeRow»«variPurpPair.variant.name» «variPurpPair.purpose.name» «ENDFOR»"'''

  def String toXml(ClosedContextualPath clCtxPath) '''
  «IF clCtxPath.variantPurposeRow != null && clCtxPath.variantPurposeRow.head != null »
  nexusId="«clCtxPath.variantPurposeRow.head.variant.name»"«ELSE»
  nexusId="«clCtxPath.closingVariant.name»"«ENDIF»
  context="«FOR variPurpPair : clCtxPath.variantPurposeRow»«variPurpPair.variant.name» «variPurpPair.purpose.name» «ENDFOR»«clCtxPath.closingVariant.name»"'''

  def String stringToXmlTag(String value, String tag) '''
    <«tag»>«value»</«tag»>
'''
  def String toXml(XLabel xlabel, String indent) '''
  «indent»<kb:label>«xlabel.label»</kb:label>
  «IF xlabel.description != null»
  «indent»<kb:description>
  «indent»«xlabel.description»
  </kb:description>
«ENDIF»
'''
   
   def String toXml(Sensor sensor) '''
  «sensor.labeledDescription.toXml("")» 
   '''
   
  def String toXml(Concept concept) '''
    <kb:concept id="«concept.name»">
      «concept.labeledDescription.toXml("")»
      <kb:attributes>
        «IF concept.listOfAttStrReferences != null»
          «FOR attRef : concept.listOfAttStrReferences»
          <kb:attribute referredValue="«attRef.ref.name»" />
          «ENDFOR»
        «ENDIF»
        «IF concept.listOfAttIntReferences != null»
          «FOR attRef : concept.listOfAttIntReferences»
          <kb:attribute referredValue="«attRef.ref.name»" />
          «ENDFOR»
        «ENDIF»
        «IF concept.listOfAttFloatReferences != null»
          «FOR attRef : concept.listOfAttFloatReferences»
          <kb:attribute referredValue="«attRef.ref.name»" />
          «ENDFOR»
        «ENDIF»
      </kb:attributes>
    </kb:concept>
  '''

  def String toXml(Variant variant) '''
    <kb:variant id="«variant.name»">
      «variant.labeledDescription.toXml("")»
      «IF (  ( variant.listOfOneOutOfThisRanges != null &&
               variant.listOfOneOutOfThisRanges.size > 0 )
          || ( variant.listOfConceptReferences != null &&
               variant.listOfConceptReferences.size > 0 )
          || ( variant.listOfOneOfTheseAttributesSections != null &&
               variant.listOfOneOfTheseAttributesSections.size > 0 ))»
      <kb:oneOfTheseUnits>
        «IF variant.listOfOneOfTheseAttributesSections != null»
          «FOR oneOutOfThisSection : variant.listOfOneOfTheseAttributesSections»
            «IF (oneOutOfThisSection.listOfStrAttReferences != null &&
                 oneOutOfThisSection.listOfStrAttReferences.size>0)»
            <kb:oneOutOfTheseStrAttributes>
              «FOR attStrRef : oneOutOfThisSection.listOfStrAttReferences»
              <kb:attribute referredValue="«attStrRef.ref.name»" />
              «ENDFOR»
            </kb:oneOutOfTheseStrAttributes>           
            «ENDIF»
            «IF (oneOutOfThisSection.listOfIntAttReferences != null &&
                 oneOutOfThisSection.listOfIntAttReferences.size>0)»
            <kb:oneOutOfTheseIntAttributes>
              «FOR attStrRef : oneOutOfThisSection.listOfIntAttReferences»
              <kb:attribute referredValue="«attStrRef.ref.name»" />
              «ENDFOR»
            </kb:oneOutOfTheseIntAttributes>           
            «ENDIF»  
            «IF (oneOutOfThisSection.listOfFloatAttReferences != null &&
                 oneOutOfThisSection.listOfFloatAttReferences.size>0)»
            <kb:oneOutOfTheseFloatAttributes>
              «FOR attStrRef : oneOutOfThisSection.listOfFloatAttReferences»
              <kb:attribute referredValue="«attStrRef.ref.name»" />
              «ENDFOR»
            </kb:oneOutOfTheseFloatAttributes>           
            «ENDIF»
          «ENDFOR»
        «ENDIF»
        «IF variant.listOfOneOutOfThisRanges != null»
        «FOR oneOutOfThisRange : variant.listOfOneOutOfThisRanges »
          «IF oneOutOfThisRange.attIntRangeReference != null »
           <kb:oneOutOfThisRange referredRange="«oneOutOfThisRange.attIntRangeReference.ref.name»" />
          «ENDIF»
          «IF oneOutOfThisRange.attFloatRangeReference != null »
            <kb:oneOutOfThisRange referredRange="«oneOutOfThisRange.attFloatRangeReference.ref.name»" />
          «ENDIF»
        «ENDFOR»
        «ENDIF»
        «IF (variant.listOfConceptReferences != null
        && variant.listOfConceptReferences.size()>0)»
        <kb:oneOfTheseConcepts>
          «FOR conc : variant.listOfConceptReferences »
          <kb:concept referredConcept="«conc.ref.name»" />
          «ENDFOR»
        </kb:oneOfTheseConcepts>
        «ENDIF»
      </kb:oneOfTheseUnits>
      «ENDIF»
    </kb:variant>
    
  '''
  
  def String toXml(IsFulfilledBy isFulFilledBy) '''
    <kb:isFulfilledBy purposeID="«isFulFilledBy.purposeRef.name»" 
      variantIDs="«FOR vari : isFulFilledBy.variantRefs»«vari.name» «ENDFOR»" />
  '''
 
  def String toXml(IsConstitutedBy isConstitutedBy) '''
    <kb:isConstitutedBy variantID="«isConstitutedBy.variantRef.name»">
      «FOR cba : isConstitutedBy.listOfisConstitutedByAssignments»
      <kb:constituent many"«cba.many»" instancesOfPurpose="«cba.purposeRef.name»" />
      «ENDFOR»
    </kb:isConstitutedBy>  
  ''' 
  def String toXml(SensorStringValueArea sensorArea) '''
  «var sensor=sensorArea.sensor»
    <kb:sensor id="«sensor.name»">
      «sensor.toXml»
      <kb:valueSet>
        «FOR value : sensorArea.sensorStringValues»
        <kb:value id="«value.name»" sensedByID="«value.sensedBy.name»">«value.value»</kb:value>
        «ENDFOR»
      </kb:valueSet>
    </kb:sensor>
   '''
  def String toXml(SensorIntDigitArea sensorArea) '''
  «var sensor=sensorArea.sensor»
    <kb:sensor id="«sensor.name»">
      «sensor.toXml»
      <kb:valueSet>
        «FOR digit : sensorArea.sensorIntDigits»
        <kb:value id="«digit.name»" sensedByID="«digit.sensedBy.name»">«digit.value»</kb:value>
        «ENDFOR»
      </kb:valueSet>
    </kb:sensor>
   '''

  def String toXml(SensorFloatDigitArea sensorArea) '''
  «var sensor=sensorArea.sensor»
    <kb:sensor id="«sensor.name»">
      «sensor.toXml»
      <kb:valueSet>
        «FOR digit : sensorArea.sensorFloatDigits»
        <kb:value id="«digit.name»" sensedByID="«digit.sensedBy.name»">«digit.value»</kb:value>
        «ENDFOR»
      </kb:valueSet>
    </kb:sensor>
  '''
  def String toXml(SensorIntRangeArea sensorArea) '''
  «var sensor=sensorArea.sensor»
    <kb:sensor id="«sensor.name»">
      «sensor.toXml»
      <kb:rangeSet>
        «FOR range : sensorArea.sensorIntRanges»
        <kb:range id="«range.name»" sensedByID="«range.sensedBy.name»"
          minVal="«range.value.minVal»" maxVal="«range.value.maxVal»" incVal="«range.value.incVal»" />
       «ENDFOR»
      </kb:rangeSet>
    </kb:sensor>
  '''
  def String toXml(SensorFloatRangeArea sensorArea) '''
  «var sensor=sensorArea.sensor»
    <kb:sensor id="«sensor.name»">
      «sensor.toXml»
      <kb:rangeSet>
        «FOR range : sensorArea.sensorFloatRanges»
        <kb:range id="«range.name»" sensedByID="«range.sensedBy.name»"
          minVal="«range.value.minVal»" maxVal="«range.value.maxVal»" incVal="«range.value.incVal»" />
       «ENDFOR»
      </kb:rangeSet>
    </kb:sensor>
'''
   
}

