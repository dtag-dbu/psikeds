grammar org.psikeds.kb.modelling.PsiKedsXtxKrl with org.eclipse.xtext.common.Terminals

/* 
 * (c) 2014 Karsten Reincke, Deutsche Telekom AG, Darmstadt
 * 
 * This file is part of the psiKeds project and licensed under the AGPL 
 */
generate psiKedsXtxKrl "http://www.psikeds.org/kb/modelling/PsiKedsXtxKrl"



/* (A) a valid psiKeds knowledge base needs ... */
KnowledgeBase:
    {KnowledgeBase}
  /* (1) a valid psiKeds knowledge base must/can offer some meta information */
  'KB-META:'
  'id' kbId=ID
  'name' kbName=STRING
  ('teaser' kbTeaser=STRING)?
  ('release' kbRelease=STRING)?
  ('(C)' kbCopyRight=STRING)?
  ('licensing' kbLicense=STRING)?
  ('created' kbFirstCreationDate=YYYYMMDD)?
  ('modified' kbLastModificationDate=YYYYMMDD)?
  ('language' kbLanguage=STRING)?
  ('engineer' (kbCreatorName+=STRING)+)?
  ('description' (kbDescription+=STRING)+)?

  /* (2) a valid psiKeds knowledge base can define some sensors and lists of
   * their specific value range. Sensors are methods to perceive / describe 
   * / denote features of real domain objects. They link the attribute-values 
   * (as they are noted in the knowledge entities) to the real world features. 
   * 
   * Sensors a type consistent: they can be lists of string values, integer 
   * values, float values, integer ranges, or float ranges.
   * 
   * [Note: 
   * - if you want to define a knowledge base being only composed of purposes, 
   *   variants, variant contexts, and logical rules, you do not need any 
   *   sensors. So, the list of sensors can be empty.
   * - what ever you want to use for describing / specifying the domain
   *   objects must be defined as sensor value in this area. Later on all
   *   knowledge base entities can only refer to these primary definitions.
   * ]
   */
  'PSIKEDS-SENSORS:'  
   (   
       ( ( listOfSensorStringAttrAreas+=SensorStringAttrArea
       | listOfSensorIntAttrAreas+=SensorIntAttrArea ) 
       | listOfSensorFloatAttrAreas+=SensorFloatAttrArea )
   )*
 
  'PSIKEDS-CONCEPTS:'
	/* (2.B) some concepts to denote / describe / cluster objects */
	(listOfConcepts+=Concept)*

  'PSIKEDS-PURPOSES:'  
	/* (3) a list of at least one purpose */
	(listOfPurposes+=Purpose)+

  'PSIKEDS-VARIANTS:'	
  /* (4) a list of at least one variant */	
	(listOfVariants+=Variant)+
	
	/* (5) a list of at least one 
	 * '[this purpose] is-fulfilled-by [these variants]' statements
	 */
	'PSIKEDS-IS-FULFILLED-BY-STATEMENTS:'
	(listOfIsFulfilledByStatements+=IsFulfilledBy)+
	
  /* (6) a possibly empty list of '[this variant] is-constituted-by 
   * [something fulfilling these purposes]' statements
   */
  'PSIKEDS-IS-CONSTITUTED-BY-STATEMENTS:'	
	(listOfIsConstitutedByStatements+=IsConstitutedBy)*

  'PSIKEDS-LOGICAL-INFERENCE-ELEMENTS:'	
	/* (7) a possibly empty list of events used by logical rules*/ 

  (   listOfContextualEnforceEvents+=ContextualEnforceEvent
    | listOfContextEventClosedByVariants+=ContextEventClosedByVariant
    | listOfContextEventClosedByStrings+=ContextEventClosedByString
    | listOfContextEventClosedByInts+=ContextEventClosedByInt
    | listOfContextEventClosedByFloats+=ContextEventClosedByFloat
    | listOfContextEventClosedByConcepts+=ContextEventClosedByConcept
  )*

  'PSIKEDS-RELATIONAL-INFERENCE-ELEMENTS:' 
  (listOfRelationsParameters+=(RelationParameter))*
    
  'PSIKEDS-INFERENCE-CONDITIONS:' 
  /* (8) a possibly empty list of logical rules */ 
 
  (	 listOfLogicalEnforcers+=LogicalEnforcer
  	| listOfLogicalRules+=LogicalRule
    | listOfNormRCs+=RelationalConstraint
    | listOfCondRCs+=ConditionedRelationalConstraint
  )*

;
 

/* (B) definitions, which are multiply used by other elements
 * either by being embedded into other xtext definitions
 * or by being used as references
 */

/* (B.0) my terminals */


terminal YYYYMMDD:
  ('0'..'9')('0'..'9')('0'..'9')('0'..'9')'-'?
  (('0'('1'..'9'))|('1'('0'..'2')))'-'?
  ( ('0'('1'..'9')) |
    (('1'|'2')('0'..'9'))|
    ('3'('0'..'1'))
  )
 ;

terminal FLOATVALUE:
  (('0'..'9')('0'..'9')*)'.'('0'..'9')('0'..'9')*
 ;

/* (B.1) an expandable label */
XLabel:
  'label' label=STRING
  ('description' description=STRING)?
;

/* (B.1) a pure label */
PLabel:
  'label' label=STRING
;

/* (B.1) a complete describing label */
DLabel:
  'label' label=STRING
  'description' description=STRING
;

/* (B.2) Sensor declaration for grouping sensor values by referencing to 
 * the grouping class: sensors are instruments for 'looking' into the domain 
 * (real world) and to deliver features of the perceived object. 
 * A sensor can/should only deliver values of the same type.
 */

Sensor:
  'sensor' name=ID '{'
  labeledDescription=XLabel
  ('unit' unit=STRING)?
  '}'
;

SensorReference:
  '*sensor>' ref=[Sensor]
;

/* (B.2.1) a sensor with an explicitly defined set of perceivable string values 
 * Note: 
 * - It is up to the knowledge engineer to insert a reference to the right 
 *   (the intended) sensor into the definition of the allowed values
 */

SensorStringAttrArea:
  sensor=Sensor
  (sensorStringValues+=SensorStringValue)+
;

SensorStringValue:
  'str.att' name=ID '[' sensedBy=[Sensor] '->' value=STRING ']'
;

/* (B.2.2) a sensor with an explicitly defined set of perceivable integer values 
 * Note: 
 * - It is up to the knowledge engineer to insert a reference to the right 
 *   (the intended) sensor into the definition of the allowed values
 */
SensorIntAttrArea:
  sensor=Sensor
  ((listOfSensorIntDigits+=SensorIntDigit)|
   (listOfSensorIntRanges+=SensorIntRange)
   )+
;

SensorIntDigit:
  'int.att' name=ID '[' sensedBy=[Sensor] '->' value=INT ']'
;

/* (B.2.3) a sensor with an explicitly defined set of perceivable float values 
 * Note: 
 * - It is up to the knowledge engineer to insert a reference to the right 
 *   (the intended) sensor into the definition of the allowed values
 */

SensorFloatAttrArea:
  sensor=Sensor
  ((listOfSensorFloatDigits+=SensorFloatDigit) |
  (listOfSensorFloatRanges+=SensorFloatRange))+
;

SensorFloatDigit:
  'float.att' name=ID '[' sensedBy=[Sensor] '->' value=FLOATVALUE ']'
;

/* 
FloatValue:
  {FloatValue}
  fval=(INT)?'.'INT
;
*/

/* (B.2.4) a sensor with an implicitly defined set of perceivable integer values
 * Note: 
 * - It is up to the knowledge engineer to insert a reference to the right 
 *   (the intended) sensor into the definition of the allowed ranges
 * - References to ranges can be assigned to variants for being decreased
 *   by functions and relations. But they can not be used in logical rules
 * - Ranges will only be usable in later versions of psiKeds (> 1.0.0)
 */

SensorIntRange:
  'int.range.att' name=ID '[' sensedBy=[Sensor] '>>' value=IntRange ']'
;

IntRange:
  '(' 'min' minVal=INT ',' 'max' maxVal=INT ',' 'inc' incVal=INT ')'
;

/* (B.2.5) a sensor with an implicitly defined set of perceivable float values
 * Note: 
 * - It is up to the knowledge engineer to insert a reference to the right 
 *   (the intended) sensor into the definition of the allowed ranges
 * - References to ranges can be assigned to variants for being decreased
 *   by functions and relations. But they can not be used in logical rules
 * - Ranges will only be usable in later versions of psiKeds (> 1.0.0)
 */

SensorFloatRange:
  'float.range.att' name=ID '[' sensedBy=[Sensor] '>>' value=FloatRange ']'
;

FloatRange:
  '(' 'min' minVal=FLOATVALUE ',' 'max' maxVal=FLOATVALUE ',' 'inc' incVal=FLOATVALUE ')'
;

/* (C) the top down definitions */

/* (C.1) elements to define concepts: Concepts are sets of different
 * attributes. An attribute is a feature value perceived by a sensor.
 * Concepts shall contain only attributes of different sensors.
 * 
 * Note:
 * - It is up to the knowledge engineer not to insert more than one value of
 *   the same sensor into one concept
 */


Concept:
  'concept' name=ID '{'
    labeledDescription=XLabel
    '['
      ( listOfAttStrReferences+=AttStrReference
      | listOfAttIntReferences+=AttIntReference
      | listOfAttFloatReferences+=AttFloatReference
      )
      ( 'and' 
        ( listOfAttStrReferences+=AttStrReference
        | listOfAttIntReferences+=AttIntReference
        | listOfAttFloatReferences+=AttFloatReference
        )
      )*
    ']'
'}';


/* (C.1.1) Attribute based on a string value */
AttStrReference:
  '*str>' ref=[SensorStringValue] 
;
/* (C.1.2) Attribute based on an integer value */
AttIntReference:
  '*int>' ref=[SensorIntDigit]
;
/* (C.1.3) Attribute based on an float value */
AttFloatReference:
  '*float>' ref=[SensorFloatDigit]
;

/* (C.1.4) Attribute based on an integer range */
AttIntRangReference:
  '*intRange>' ref=[SensorIntRange]
;
/* (C.1.5) Attribute based on an float range */
AttFloatRangeReference:
  '*floatRange>' ref=[SensorFloatRange]
;

ConceptReference:
  '*concept>' ref=[Concept]
;

/* (C.2) definitions of purposes  */ 
Purpose:
	'purpose' name=ID '{'
	 	('root' root=('true'|'false'))?
	 	labeledDescription=XLabel
	'}'
;

/* (C.3) definitions of variants  */

Variant:
	'variant' name=ID '{'
    labeledDescription=XLabel
   /* 0 - n lists of one of these context-free features */
   (listOfOneOfTheseAttributesSections+=(OneOfTheseAttributesSection)*)
   /* one list of one of these terminal concepts */
   
   (listOfOneOutOfThisRanges+=(OneOutOfThisRange)*)
     
   ('classified.as ['
    ( listOfConceptReferences+=ConceptReference
      ( 'or' listOfConceptReferences+=ConceptReference )*
    )
    ']')?  
	'}'
;	

VariantReference:
  '*variant>' ref=[Variant]
;

OneOfTheseAttributesSection:
   'specified.by' sensor=[Sensor] 'as ['
      
     ( ( listOfStrAttReferences+=AttStrReference
       ( 'or' listOfStrAttReferences+=AttStrReference )*)
       
     | (listOfIntAttReferences+=AttIntReference
       ( 'or' listOfIntAttReferences+=AttIntReference )*)
       
     | (listOfFloatAttReferences+=AttFloatReference
       ( 'or' listOfFloatAttReferences+=AttFloatReference )*)
     )
   ']'
;

OneOutOfThisRange:
   'perceived.by' sensor=[Sensor] 'within' 
    ( attIntRangeReference=AttIntRangReference
      | attFloatRangeReference=AttFloatRangeReference
    )         
;
/* (C.4) is fulfilled by statement  */

IsFulfilledBy:
  'purpose.system' purposeRef=[Purpose] 'isFulfilledBy' '{' 
    (variantRefs+=[Variant])+ '}'
;

/* (C.5) is constituted by statement   */
 
IsConstitutedBy:
  'purpose.variant' variantRef=[Variant] 'isConstitutedBy' '{'
    (listOfisConstitutedByAssignments+=IsConstitutedByAssignment)+ 
  '}'
;

IsConstitutedByAssignment:
  '<' many=INT 'instance(s)-of' purposeRef=[Purpose] '>'
;

/* (C.6) elements for defining events being perceptible during the inference process*/

ContextualEnforceEvent:
  'event.enforcing' name=ID '['
    labeledDescription=XLabel
    'context=fact' fact=VariantReference
  ']'
;

ContextualLogicEvent:
	ContextEventClosedByVariant
    | ContextEventClosedByString
    | ContextEventClosedByInt
    | ContextEventClosedByFloat
    | ContextEventClosedByConcept
;


/* Note:
 * - it is up to the knowledge engineer to select the same variant
 *   as context and as fact!
 */
ContextEventClosedByVariant:
  'event.var' name=ID '['
    labeledDescription=XLabel
    'context' context=OpenContextualPath
     (negation?='NOT')?
    'fact' fact=VariantReference
  ']'
;


ContextEventClosedByString:
  'event.str' name=ID '['
    labeledDescription=XLabel
    'context' context=ClosedContextualPath
    (negation?='NOT')?
    'fact' fact=AttStrReference
  ']'
;

ContextEventClosedByInt:
  'event.int' name=ID '['
    labeledDescription=XLabel
    'context' context=ClosedContextualPath
    (negation?='NOT')?
    'fact' fact=AttIntReference
  ']'
;

ContextEventClosedByFloat:
  'event.float' name=ID '['
    labeledDescription=XLabel
    'context' context=ClosedContextualPath
    (negation?='NOT')?
    'fact' fact=AttFloatReference
  ']'
;

ContextEventClosedByConcept:
  'event.concept' name=ID '['
    labeledDescription=XLabel
    'context' context=ClosedContextualPath
    (negation?='NOT')?
    'fact' fact=ConceptReference
  ']'
;

RelationParameter:
  'relation.param' name=ID '['
    labeledDescription=XLabel
    'context' context=ClosedContextualPath
    'value.type' fact=SensorReference
  ']'
;
 
ClosedContextualPath:
  '<'
  (variantPurposeRow += VariantPurposePair)*
  closingVariant = [Variant]
  '>'
;

OpenContextualPath:
  '<'
  (variantPurposeRow += VariantPurposePair)+
  '>'
;

VariantPurposePair:
    variant=[Variant]
    purpose=[Purpose]
;

LogicalEnforcer:
  'logic.enforcer' 
   name=ID 
   labeledDescription=XLabel
  'means ('
	   premise=[ContextualEnforceEvent]
	 '->'
	   conclusio=[ContextualLogicEvent]
	')'
;

LogicalRule:
  'logic.rule'
   name=ID 
   labeledDescription=XLabel
   'means ({'
   listOfPremiseEvents+=[ContextualLogicEvent]
   ( 'and' listOfPremiseEvents+=[ContextualLogicEvent])*
   '} ->'
    conclusio=[ContextualLogicEvent]
   ')'
;


enum RelationType:
  equal | unequal | less | lessOrEqual
;

RelationalConstraint:
  'relation.normal'
   name=ID 
   labeledDescription=XLabel
   'means (' 
      stmnt=RelationalStatement
   ')'
;


ConditionedRelationalConstraint:
  'relation.qualified'
   name=ID 
   labeledDescription=XLabel
   'means ('
      'if'
      trigger=[ContextualLogicEvent]
      'then'
      stmnt=RelationalStatement
  ')'
;

RelationalStatement:
      ( ( ( 'valFrom' leVarArg=[RelationParameter] 
            relType=RelationType
            (   'constStr' riStrConst=[SensorStringValue]
              | 'constInt' riIntConst=[SensorIntDigit]
              | 'constFloat' riFloatConst=[SensorFloatDigit]       
            )
          )
          |
          ( ( 'constStr' leStrConst=[SensorStringValue]
              | 'constInt' leIntConst=[SensorIntDigit]
              | 'constFloat' leFloatConst=[SensorFloatDigit]       
            )
            relType=RelationType
            'valFrom' riVarArg=[RelationParameter] 
          )  
        )
        |
        ( 'valFrom' leVarArg=[RelationParameter] 
          relType=RelationType
          'valFrom' riVarArg=[RelationParameter] 
        )  
      )    
;